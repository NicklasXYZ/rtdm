# Generated by Django 3.1.2 on 2021-10-04 22:46

import backend.fields
from django.db import migrations, models
import django.db.models.deletion
import ruuid.ruuid


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='DeviceMotionData',
            fields=[
                ('uid', models.UUIDField(default=ruuid.ruuid.uuid4, editable=False, help_text='The unique identifier for the device motion data.', primary_key=True, serialize=False, unique=True, verbose_name='device motion uid')),
                ('external_timestamp', models.DateTimeField(help_text='The externally given timestamp.', verbose_name='external timestamp')),
                ('x', models.FloatField(blank=True, default=None, null=True, verbose_name='')),
                ('y', models.FloatField(blank=True, default=None, null=True, verbose_name='')),
                ('z', models.FloatField(blank=True, default=None, null=True, verbose_name='')),
            ],
            options={
                'verbose_name': 'Device Motion Data',
                'verbose_name_plural': 'Device Motion Data',
                'ordering': ['external_timestamp'],
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='MagnetometerData',
            fields=[
                ('uid', models.UUIDField(default=ruuid.ruuid.uuid4, editable=False, help_text='The unique identifier for the magnetometer data.', primary_key=True, serialize=False, unique=True, verbose_name='magnetometer uid')),
                ('internal_timestamp', models.DateTimeField(auto_now_add=True, help_text='The internally set timestamp.', verbose_name='internal timestamp')),
                ('x', models.FloatField(blank=True, default=None, null=True, verbose_name='')),
                ('y', models.FloatField(blank=True, default=None, null=True, verbose_name='')),
                ('z', models.FloatField(blank=True, default=None, null=True, verbose_name='')),
                ('magnitude', models.FloatField(blank=True, default=None, null=True, verbose_name='')),
            ],
            options={
                'verbose_name': 'Magnetometer Data',
                'verbose_name_plural': 'Magnetometer Data',
                'ordering': ['internal_timestamp'],
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='Sequence',
            fields=[
                ('uid', models.UUIDField(default=ruuid.ruuid.uuid4, editable=False, help_text='The unique identifier of the sequence.', primary_key=True, serialize=False, unique=True, verbose_name='uid')),
                ('tokens', backend.fields.MsgPackField(blank=True, help_text='A list of tokens that make up a sequence.', null=True, verbose_name='tokens')),
                ('user', models.UUIDField(editable=False, help_text='The unique identifier of the user.', verbose_name='user')),
            ],
            options={
                'verbose_name': 'Sequence',
                'verbose_name_plural': 'Sequences',
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='SupportSet',
            fields=[
                ('uid', models.UUIDField(default=ruuid.ruuid.uuid4, editable=False, help_text='The unique identifier of the support set.', primary_key=True, serialize=False, unique=True, verbose_name='uid')),
                ('updated', models.DateTimeField(auto_now=True, help_text='The date the user joined.', verbose_name='join date')),
                ('patterns', backend.fields.MsgPackField(blank=True, help_text='A list of patterns that are (frequency, sequence) pairs.', null=True, verbose_name='patterns')),
                ('user', models.UUIDField(editable=False, help_text='The unique identifier of the user.', verbose_name='user')),
            ],
            options={
                'verbose_name': 'SupportSet',
                'verbose_name_plural': 'SupportSets',
                'ordering': ['updated'],
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='Trajectory',
            fields=[
                ('uid', models.UUIDField(default=ruuid.ruuid.uuid4, editable=False, help_text='The unique identifier of the trajectory.', primary_key=True, serialize=False, unique=True, verbose_name='unique identifier')),
                ('color', models.CharField(blank=True, default='#1a48a1', help_text='The color used to represent the trajectory.', max_length=250, null=True, verbose_name='color')),
                ('start_timestamp', models.DateTimeField(blank=True, help_text='The first timestamp of a datapoint in the trajectory.', null=True, verbose_name='start timestamp')),
                ('end_timestamp', models.DateTimeField(blank=True, help_text='The last timestamp of a datapoint in the trajectory.', null=True, verbose_name='end timestamp')),
                ('user', models.UUIDField(editable=False, help_text='The unique identifier of the user.', verbose_name='user')),
                ('tag', models.CharField(blank=True, help_text='A tag used to categorize trajectories.', max_length=250, null=True, verbose_name='tag')),
                ('trajectory', models.ForeignKey(blank=True, help_text='The trajectory a subtrajectory belongs to.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='subtrajectories', to='backend.trajectory', verbose_name='trajectory')),
            ],
            options={
                'verbose_name': 'Trajectory',
                'verbose_name_plural': 'Trajectories',
                'ordering': ['start_timestamp'],
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='DataPoint',
            fields=[
                ('uid', models.UUIDField(default=ruuid.ruuid.uuid4, editable=False, help_text='The unique identifier of the datapoint.', primary_key=True, serialize=False, unique=True, verbose_name='datapoint uid')),
                ('external_timestamp', models.DateTimeField(help_text='The externally given timestamp.', null=True, verbose_name='external timestamp')),
                ('accuracy', models.FloatField(blank=True, default=None, help_text='The estimated horizontal accuracy of the location in             meters, if it is available.', null=True, verbose_name='accuracy')),
                ('speed', models.FloatField(blank=True, default=None, help_text='The speed in meters/second over ground, if it is available.', null=True, verbose_name='speed')),
                ('acceleration', models.FloatField(blank=True, default=None, help_text='The acceleration in meters/second^2 over ground, if it is         available.', null=True, verbose_name='speed')),
                ('latitude', models.FloatField(help_text='The latitude of the location in degrees.', verbose_name='latitude')),
                ('longitude', models.FloatField(help_text='The longitude of the location in degrees.', verbose_name='longitude')),
                ('user', models.UUIDField(editable=False, help_text='The unique identifier of the user.', verbose_name='user')),
                ('label', models.CharField(blank=True, help_text='The label of the datapoint.', max_length=250, null=True, verbose_name='label')),
                ('weight', models.FloatField(help_text='The weight assigned to the datapoint.', verbose_name='weight')),
                ('dx', models.FloatField(help_text='The change in distance from previous datapoint.', verbose_name='dx')),
                ('dt', models.FloatField(help_text='The change in time from the previous datapoint.', verbose_name='dt')),
                ('datapoints', backend.fields.MsgPackField(blank=True, help_text='A list of datapoints. The list is non-empty if the             datapoint is an aggregate datapoint representing several             datapoints that are in the vicinity of each other.', null=True, verbose_name='datapoints')),
                ('devicemotion', models.OneToOneField(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='datapoint_devicemotion', to='backend.devicemotiondata', verbose_name='')),
                ('magnetometer', models.OneToOneField(blank=True, null=True, on_delete=django.db.models.deletion.CASCADE, related_name='datapoint_magnetometer', to='backend.magnetometerdata', verbose_name='')),
                ('trajectory', models.ForeignKey(help_text='The trajectory the datapoint is associated with.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='datapoints', to='backend.trajectory', verbose_name='trajectory')),
            ],
            options={
                'verbose_name': 'Data Point',
                'verbose_name_plural': 'Data Points',
                'ordering': ['external_timestamp'],
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='BreakPoint',
            fields=[
                ('uid', models.UUIDField(default=ruuid.ruuid.uuid4, editable=False, help_text='The unique identifier of the breakpoint.', primary_key=True, serialize=False, unique=True, verbose_name='breakpoint uid')),
                ('start_index', models.DateTimeField(help_text='A timestamp.', null=True, verbose_name='')),
                ('scan_index', models.DateTimeField(help_text='A timestamp.', null=True, verbose_name='')),
                ('last_index', models.DateTimeField(help_text='A timestamp.', null=True, verbose_name='')),
                ('label', models.CharField(blank=True, help_text='.', max_length=250, null=True, verbose_name='')),
                ('user', models.UUIDField(editable=False, help_text='The unique identifier of the user.', verbose_name='user')),
                ('trajectory', models.ForeignKey(blank=True, help_text='The trajectory the breakpoint is associated with.', null=True, on_delete=django.db.models.deletion.CASCADE, related_name='breakpoints', to='backend.trajectory', verbose_name='trajectory')),
            ],
            options={
                'verbose_name': 'Break Point',
                'verbose_name_plural': 'Break Points',
                'ordering': ['scan_index'],
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='User',
            fields=[
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('uid', models.UUIDField(default=ruuid.ruuid.uuid4, editable=False, help_text='The unique identifier of the user.', primary_key=True, serialize=False, unique=True, verbose_name='unique identifier')),
                ('username', models.CharField(help_text='The username of the user.', max_length=250, unique=True, verbose_name='username')),
                ('password', models.CharField(blank=True, help_text='The password of the user.', max_length=250, null=True, verbose_name='password')),
                ('date_joined', models.DateTimeField(auto_now_add=True, help_text='The date the user joined.', verbose_name='join date')),
                ('is_admin', models.BooleanField(default=False, help_text='Specifies whether the user is an administrator.', verbose_name='is admin')),
                ('is_superuser', models.BooleanField(default=False, help_text='Specifies whether the user is a superuser.', verbose_name='is superuser')),
                ('is_staff', models.BooleanField(default=False, help_text='Specifies whether the user is a part of the staff.', verbose_name='is staff')),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.Group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.Permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'User',
                'verbose_name_plural': 'Users',
                'ordering': ['date_joined'],
                'abstract': False,
            },
        ),
    ]
